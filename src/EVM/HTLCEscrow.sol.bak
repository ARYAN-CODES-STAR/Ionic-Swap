// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title HTLCEscrow
 * @dev Implements Hashed Timelock Contract (HTLC) for 1inch Fusion+ cross-chain swaps
 * This contract acts as Escrow A or Escrow B in the 1inch Fusion+ swap flow
 */
contract HTLCEscrow is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    // HTLC structure
    struct HTLC {
        address sender;
        address recipient;
        uint256 amount;
        bytes32 hashlock;
        uint256 timelock;
        bool withdrawn;
        bool refunded;
        string secret;
    }

    // State variables
    mapping(bytes32 => HTLC) public htlcContracts;
    mapping(address => bytes32[]) public userHTLCs;
    
    // Events
    event HTLCCreated(
        bytes32 indexed htlcId,
        address indexed sender,
        address indexed recipient,
        uint256 amount,
        bytes32 hashlock,
        uint256 timelock
    );
    
    event HTLCWithdrawn(
        bytes32 indexed htlcId,
        string secret
    );
    
    event HTLCRefunded(
        bytes32 indexed htlcId
    );

    // Modifiers
    modifier htlcExists(bytes32 htlcId) {
        require(htlcContracts[htlcId].sender != address(0), "HTLC does not exist");
        _;
    }

    modifier notWithdrawn(bytes32 htlcId) {
        require(!htlcContracts[htlcId].withdrawn, "HTLC already withdrawn");
        _;
    }

    modifier notRefunded(bytes32 htlcId) {
        require(!htlcContracts[htlcId].refunded, "HTLC already refunded");
        _;
    }

    modifier notExpired(bytes32 htlcId) {
        require(block.timestamp < htlcContracts[htlcId].timelock, "HTLC expired");
        _;
    }

    modifier onlyRecipient(bytes32 htlcId) {
        require(msg.sender == htlcContracts[htlcId].recipient, "Only recipient can withdraw");
        _;
    }

    modifier onlySender(bytes32 htlcId) {
        require(msg.sender == htlcContracts[htlcId].sender, "Only sender can refund");
        _;
    }

    /**
     * @dev Create a new HTLC for ERC20 tokens
     * @param recipient The address that can claim the HTLC
     * @param amount The amount of tokens to lock
     * @param hashlock The hash of the secret
     * @param timelock The expiration time
     * @param token The ERC20 token address
     */
    function createHTLC(
        address recipient,
        uint256 amount,
        bytes32 hashlock,
        uint256 timelock,
        address token
    ) external nonReentrant returns (bytes32 htlcId) {
        require(recipient != address(0), "Invalid recipient");
        require(amount > 0, "Amount must be greater than 0");
        require(timelock > block.timestamp, "Timelock must be in the future");
        require(hashlock != bytes32(0), "Invalid hashlock");

        htlcId = keccak256(abi.encodePacked(
            msg.sender,
            recipient,
            amount,
            hashlock,
            timelock,
            block.timestamp
        ));

        require(htlcContracts[htlcId].sender == address(0), "HTLC already exists");

        // Transfer tokens from sender to contract
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);

        // Create HTLC
        htlcContracts[htlcId] = HTLC({
            sender: msg.sender,
            recipient: recipient,
            amount: amount,
            hashlock: hashlock,
            timelock: timelock,
            withdrawn: false,
            refunded: false,
            secret: ""
        });

        userHTLCs[msg.sender].push(htlcId);
        userHTLCs[recipient].push(htlcId);

        emit HTLCCreated(htlcId, msg.sender, recipient, amount, hashlock, timelock);
    }

    /**
     * @dev Create a new HTLC for native ETH
     * @param recipient The address that can claim the HTLC
     * @param hashlock The hash of the secret
     * @param timelock The expiration time
     */
    function createHTLCETH(
        address recipient,
        bytes32 hashlock,
        uint256 timelock
    ) external payable nonReentrant returns (bytes32 htlcId) {
        require(recipient != address(0), "Invalid recipient");
        require(msg.value > 0, "Amount must be greater than 0");
        require(timelock > block.timestamp, "Timelock must be in the future");
        require(hashlock != bytes32(0), "Invalid hashlock");

        htlcId = keccak256(abi.encodePacked(
            msg.sender,
            recipient,
            msg.value,
            hashlock,
            timelock,
            block.timestamp
        ));

        require(htlcContracts[htlcId].sender == address(0), "HTLC already exists");

        // Create HTLC (ETH is already transferred to contract)
        htlcContracts[htlcId] = HTLC({
            sender: msg.sender,
            recipient: recipient,
            amount: msg.value,
            hashlock: hashlock,
            timelock: timelock,
            withdrawn: false,
            refunded: false,
            secret: ""
        });

        userHTLCs[msg.sender].push(htlcId);
        userHTLCs[recipient].push(htlcId);

        emit HTLCCreated(htlcId, msg.sender, recipient, msg.value, hashlock, timelock);
    }

    /**
     * @dev Withdraw HTLC with the secret
     * @param htlcId The HTLC ID
     * @param secret The secret that matches the hashlock
     * @param token The ERC20 token address (use address(0) for ETH)
     */
    function withdrawHTLC(
        bytes32 htlcId,
        string calldata secret,
        address token
    ) external htlcExists(htlcId) notWithdrawn(htlcId) notRefunded(htlcId) notExpired(htlcId) onlyRecipient(htlcId) nonReentrant {
        HTLC storage htlc = htlcContracts[htlcId];
        
        // Verify the secret matches the hashlock
        require(keccak256(abi.encodePacked(secret)) == htlc.hashlock, "Invalid secret");

        htlc.withdrawn = true;
        htlc.secret = secret;

        if (token == address(0)) {
            // Withdraw ETH
            (bool success, ) = htlc.recipient.call{value: htlc.amount}("");
            require(success, "ETH transfer failed");
        } else {
            // Withdraw ERC20 tokens
            IERC20(token).safeTransfer(htlc.recipient, htlc.amount);
        }

        emit HTLCWithdrawn(htlcId, secret);
    }

    /**
     * @dev Refund HTLC after expiration
     * @param htlcId The HTLC ID
     * @param token The ERC20 token address (use address(0) for ETH)
     */
    function refundHTLC(
        bytes32 htlcId,
        address token
    ) external htlcExists(htlcId) notWithdrawn(htlcId) notRefunded(htlcId) onlySender(htlcId) nonReentrant {
        HTLC storage htlc = htlcContracts[htlcId];
        
        require(block.timestamp >= htlc.timelock, "HTLC not expired");

        htlc.refunded = true;

        if (token == address(0)) {
            // Refund ETH
            (bool success, ) = htlc.sender.call{value: htlc.amount}("");
            require(success, "ETH transfer failed");
        } else {
            // Refund ERC20 tokens
            IERC20(token).safeTransfer(htlc.sender, htlc.amount);
        }

        emit HTLCRefunded(htlcId);
    }

    /**
     * @dev Get HTLC details
     * @param htlcId The HTLC ID
     */
    function getHTLC(bytes32 htlcId) external view returns (HTLC memory) {
        return htlcContracts[htlcId];
    }

    /**
     * @dev Get user's HTLCs
     * @param user The user address
     */
    function getUserHTLCs(address user) external view returns (bytes32[] memory) {
        return userHTLCs[user];
    }

    /**
     * @dev Check if HTLC is expired
     * @param htlcId The HTLC ID
     */
    function isExpired(bytes32 htlcId) external view returns (bool) {
        return block.timestamp >= htlcContracts[htlcId].timelock;
    }

    /**
     * @dev Emergency withdraw function for owner (only for stuck tokens)
     * @param token The token address
     * @param amount The amount to withdraw
     */
    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        if (token == address(0)) {
            (bool success, ) = owner().call{value: amount}("");
            require(success, "ETH transfer failed");
        } else {
            IERC20(token).safeTransfer(owner(), amount);
        }
    }

    // Allow contract to receive ETH
    receive() external payable {}
} 