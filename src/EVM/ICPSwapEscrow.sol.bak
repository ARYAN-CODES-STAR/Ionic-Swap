// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

/**
 * @title ICPSwapEscrow
 * @dev Implements cross-chain atomic swaps between Ethereum and ICP using Chain-Key signatures
 * This contract extends 1inch Fusion+ by creating a new asset type: "Proof of ICP Lock"
 */
contract ICPSwapEscrow is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;
    using ECDSA for bytes32;

    // Chain-Key signature verification
    bytes32 public constant ICP_NETWORK_PUBLIC_KEY = keccak256(abi.encodePacked(
        "ICP_NETWORK_PUBLIC_KEY"
    ));
    
    // ICP Network public key (this would be the actual ICP network's public key)
    // For demo purposes, we'll use a placeholder that can be updated
    address public icpNetworkSigner;
    
    // HTLC structure for cross-chain swaps
    struct CrossChainHTLC {
        address maker;           // User creating the swap
        address taker;           // User filling the swap
        uint256 amount;          // Amount of ETH/ERC20 tokens
        bytes32 hashlock;        // Hash of the secret
        uint256 timelock;        // Expiration timestamp
        bool claimed;            // Whether the swap was claimed
        bool refunded;           // Whether the swap was refunded
        string secret;           // The secret (only available after claim)
        address token;           // ERC20 token address (address(0) for ETH)
        bytes32 icpProof;        // Chain-Key signature proof from ICP
    }
    
    // State variables
    mapping(bytes32 => CrossChainHTLC) public htlcSwaps;
    mapping(address => bytes32[]) public userSwaps;
    
    // Events
    event CrossChainSwapCreated(
        bytes32 indexed swapId,
        address indexed maker,
        address indexed taker,
        uint256 amount,
        bytes32 hashlock,
        uint256 timelock,
        address token
    );
    
    event CrossChainSwapClaimed(
        bytes32 indexed swapId,
        string secret,
        bytes32 icpProof
    );
    
    event CrossChainSwapRefunded(
        bytes32 indexed swapId
    );
    
    event ICPNetworkSignerUpdated(
        address indexed oldSigner,
        address indexed newSigner
    );

    // Modifiers
    modifier swapExists(bytes32 swapId) {
        require(htlcSwaps[swapId].maker != address(0), "Swap does not exist");
        _;
    }

    modifier notClaimed(bytes32 swapId) {
        require(!htlcSwaps[swapId].claimed, "Swap already claimed");
        _;
    }

    modifier notRefunded(bytes32 swapId) {
        require(!htlcSwaps[swapId].refunded, "Swap already refunded");
        _;
    }

    modifier notExpired(bytes32 swapId) {
        require(block.timestamp < htlcSwaps[swapId].timelock, "Swap expired");
        _;
    }

    modifier onlyTaker(bytes32 swapId) {
        require(msg.sender == htlcSwaps[swapId].taker, "Only taker can claim");
        _;
    }

    modifier onlyMaker(bytes32 swapId) {
        require(msg.sender == htlcSwaps[swapId].maker, "Only maker can refund");
        _;
    }

    constructor(address _icpNetworkSigner) {
        icpNetworkSigner = _icpNetworkSigner;
    }

    /**
     * @dev Create a cross-chain swap for ETH
     * @param taker The address that can claim the swap
     * @param hashlock The hash of the secret
     * @param timelock The expiration timestamp
     */
    function createSwapETH(
        address taker,
        bytes32 hashlock,
        uint256 timelock
    ) external payable nonReentrant returns (bytes32 swapId) {
        require(taker != address(0), "Invalid taker");
        require(msg.value > 0, "Amount must be greater than 0");
        require(timelock > block.timestamp, "Timelock must be in the future");
        require(hashlock != bytes32(0), "Invalid hashlock");

        swapId = keccak256(abi.encodePacked(
            msg.sender,
            taker,
            msg.value,
            hashlock,
            timelock,
            block.timestamp
        ));

        require(htlcSwaps[swapId].maker == address(0), "Swap already exists");

        // Create the cross-chain swap
        htlcSwaps[swapId] = CrossChainHTLC({
            maker: msg.sender,
            taker: taker,
            amount: msg.value,
            hashlock: hashlock,
            timelock: timelock,
            claimed: false,
            refunded: false,
            secret: "",
            token: address(0),
            icpProof: bytes32(0)
        });

        userSwaps[msg.sender].push(swapId);
        userSwaps[taker].push(swapId);

        emit CrossChainSwapCreated(swapId, msg.sender, taker, msg.value, hashlock, timelock, address(0));
    }

    /**
     * @dev Create a cross-chain swap for ERC20 tokens
     * @param taker The address that can claim the swap
     * @param amount The amount of tokens to lock
     * @param hashlock The hash of the secret
     * @param timelock The expiration timestamp
     * @param token The ERC20 token address
     */
    function createSwapERC20(
        address taker,
        uint256 amount,
        bytes32 hashlock,
        uint256 timelock,
        address token
    ) external nonReentrant returns (bytes32 swapId) {
        require(taker != address(0), "Invalid taker");
        require(amount > 0, "Amount must be greater than 0");
        require(timelock > block.timestamp, "Timelock must be in the future");
        require(hashlock != bytes32(0), "Invalid hashlock");
        require(token != address(0), "Invalid token address");

        swapId = keccak256(abi.encodePacked(
            msg.sender,
            taker,
            amount,
            hashlock,
            timelock,
            block.timestamp
        ));

        require(htlcSwaps[swapId].maker == address(0), "Swap already exists");

        // Transfer tokens from maker to contract
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);

        // Create the cross-chain swap
        htlcSwaps[swapId] = CrossChainHTLC({
            maker: msg.sender,
            taker: taker,
            amount: amount,
            hashlock: hashlock,
            timelock: timelock,
            claimed: false,
            refunded: false,
            secret: "",
            token: token,
            icpProof: bytes32(0)
        });

        userSwaps[msg.sender].push(swapId);
        userSwaps[taker].push(swapId);

        emit CrossChainSwapCreated(swapId, msg.sender, taker, amount, hashlock, timelock, token);
    }

    /**
     * @dev Claim a cross-chain swap with Chain-Key signature proof
     * @param swapId The swap ID
     * @param secret The secret that matches the hashlock
     * @param icpProof The Chain-Key signature proof from ICP
     * @param signature The signature of the ICP proof
     */
    function claimSwap(
        bytes32 swapId,
        string calldata secret,
        bytes32 icpProof,
        bytes calldata signature
    ) external swapExists(swapId) notClaimed(swapId) notRefunded(swapId) notExpired(swapId) onlyTaker(swapId) nonReentrant {
        CrossChainHTLC storage swap = htlcSwaps[swapId];
        
        // Verify the secret matches the hashlock
        require(keccak256(abi.encodePacked(secret)) == swap.hashlock, "Invalid secret");

        // Verify the Chain-Key signature proof
        require(verifyICPProof(swapId, icpProof, signature), "Invalid ICP proof");

        swap.claimed = true;
        swap.secret = secret;
        swap.icpProof = icpProof;

        // Transfer assets to taker
        if (swap.token == address(0)) {
            // Transfer ETH
            (bool success, ) = swap.taker.call{value: swap.amount}("");
            require(success, "ETH transfer failed");
        } else {
            // Transfer ERC20 tokens
            IERC20(swap.token).safeTransfer(swap.taker, swap.amount);
        }

        emit CrossChainSwapClaimed(swapId, secret, icpProof);
    }

    /**
     * @dev Refund a cross-chain swap after expiration
     * @param swapId The swap ID
     */
    function refundSwap(
        bytes32 swapId
    ) external swapExists(swapId) notClaimed(swapId) notRefunded(swapId) onlyMaker(swapId) nonReentrant {
        CrossChainHTLC storage swap = htlcSwaps[swapId];
        
        require(block.timestamp >= swap.timelock, "Swap not expired");

        swap.refunded = true;

        // Refund assets to maker
        if (swap.token == address(0)) {
            // Refund ETH
            (bool success, ) = swap.maker.call{value: swap.amount}("");
            require(success, "ETH transfer failed");
        } else {
            // Refund ERC20 tokens
            IERC20(swap.token).safeTransfer(swap.maker, swap.amount);
        }

        emit CrossChainSwapRefunded(swapId);
    }

    /**
     * @dev Verify Chain-Key signature proof from ICP
     * @param swapId The swap ID
     * @param icpProof The proof from ICP
     * @param signature The Chain-Key signature
     */
    function verifyICPProof(
        bytes32 swapId,
        bytes32 icpProof,
        bytes calldata signature
    ) public view returns (bool) {
        // Construct the message that should have been signed by ICP
        bytes32 messageHash = keccak256(abi.encodePacked(
            "\x19Ethereum Signed Message:\n32",
            keccak256(abi.encodePacked(
                swapId,
                icpProof,
                "ICP_LOCK_VERIFICATION"
            ))
        ));

        // Recover the signer from the signature
        address signer = messageHash.recover(signature);
        
        // Verify the signer is the ICP network
        return signer == icpNetworkSigner;
    }

    /**
     * @dev Update the ICP network signer (only owner)
     * @param newSigner The new ICP network signer address
     */
    function updateICPNetworkSigner(address newSigner) external onlyOwner {
        require(newSigner != address(0), "Invalid signer address");
        address oldSigner = icpNetworkSigner;
        icpNetworkSigner = newSigner;
        emit ICPNetworkSignerUpdated(oldSigner, newSigner);
    }

    /**
     * @dev Get swap details
     * @param swapId The swap ID
     */
    function getSwap(bytes32 swapId) external view returns (CrossChainHTLC memory) {
        return htlcSwaps[swapId];
    }

    /**
     * @dev Get user's swaps
     * @param user The user address
     */
    function getUserSwaps(address user) external view returns (bytes32[] memory) {
        return userSwaps[user];
    }

    /**
     * @dev Check if swap is expired
     * @param swapId The swap ID
     */
    function isExpired(bytes32 swapId) external view returns (bool) {
        return block.timestamp >= htlcSwaps[swapId].timelock;
    }

    /**
     * @dev Emergency withdraw function for owner (only for stuck tokens)
     * @param token The token address
     * @param amount The amount to withdraw
     */
    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        if (token == address(0)) {
            (bool success, ) = owner().call{value: amount}("");
            require(success, "ETH transfer failed");
        } else {
            IERC20(token).safeTransfer(owner(), amount);
        }
    }

    // Allow contract to receive ETH
    receive() external payable {}
} 