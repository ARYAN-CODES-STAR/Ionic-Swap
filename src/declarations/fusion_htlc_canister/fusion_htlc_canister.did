type http_header = 
 record {
   name: text;
   value: text;
 };
type RpcServices = 
 variant {
   ArbitrumOne: opt vec L2MainnetService;
   BaseMainnet: opt vec L2MainnetService;
   Custom: record {
             chainId: nat64;
             services: vec RpcApi;
           };
   EthMainnet: opt vec EthMainnetService;
   EthSepolia: opt vec EthSepoliaService;
   OptimismMainnet: opt vec L2MainnetService;
 };
type RpcApi = 
 record {
   headers: opt vec HttpHeader;
   url: text;
 };
type Result_9 = 
 variant {
   err: text;
   ok: EvmChainConfig;
 };
type Result_8 = 
 variant {
   err: text;
   ok: nat;
 };
type Result_7 = 
 variant {
   err: text;
   ok: EvmHtlcInteraction;
 };
type Result_6 = 
 variant {
   err: text;
   ok: HTLC;
 };
type Result_5 = 
 variant {
   err: text;
   ok: vec PartialFill;
 };
type Result_4 = 
 variant {
   err: text;
   ok: PartialFill;
 };
type Result_3 = 
 variant {
   err: text;
   ok: Resolver;
 };
type Result_2 = 
 variant {
   err: text;
   ok: bool;
 };
type Result_10 = 
 variant {
   err: text;
   ok: HTLCOrder;
 };
type Result_1 = 
 variant {
   err: text;
   ok: text;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type Resolver = 
 record {
   address: text;
   is_active: bool;
   last_active: int;
   success_rate: float64;
   supported_chains: vec ChainType;
   total_fills: nat;
 };
type PartialFill = 
 record {
   amount: nat;
   fill_id: text;
   fill_timestamp: int;
   htlc_id: text;
   resolver_address: text;
   secret_hash: text;
   status: variant {
             Completed;
             Failed;
             Pending;
           };
 };
type OneInchOrder = 
 record {
   dst_chain_id: nat;
   fills: vec text;
   hashlock: text;
   maker: text;
   maker_asset: text;
   making_amount: text;
   order_hash: text;
   secret_hashes: vec text;
   src_chain_id: nat;
   taker: text;
   taker_asset: text;
   taking_amount: text;
   timelock: int;
 };
type L2MainnetService = 
 variant {
   Alchemy;
   Ankr;
   BlockPi;
   Llama;
   PublicNode;
 };
type HttpResponseResult = 
 record {
   body: blob;
   headers: vec http_header;
   status: nat;
 };
type HttpHeader = 
 record {
   name: text;
   value: text;
 };
type HTLCStatus = 
 variant {
   Claimed;
   Expired;
   Locked;
   Refunded;
 };
type HTLCOrder = 
 record {
   htlc_id: text;
   is_source_chain: bool;
   merkle_root: opt text;
   oneinch_order: OneInchOrder;
   partial_fill_index: opt nat;
   partial_fills: vec text;
   remaining_amount: nat;
   total_filled: nat;
 };
type HTLC = 
 record {
   amount: nat;
   chain_type: ChainType;
   created_at: int;
   ethereum_address: opt text;
   expiration_time: int;
   hashlock: blob;
   id: text;
   recipient: principal;
   secret: opt text;
   sender: principal;
   status: HTLCStatus;
   token_canister: principal;
 };
type EvmHtlcInteraction = 
 record {
   action: variant {
             Claim;
             Create;
             Refund;
           };
   evm_htlc_address: text;
   htlc_id: text;
   secret: opt text;
   status: variant {
             Confirmed;
             Failed;
             Pending;
           };
   transaction_hash: opt text;
 };
type EvmChainConfig = 
 record {
   chain_id: nat;
   gas_limit: nat;
   gas_price: nat;
   htlc_contract_address: opt text;
   rpc_services: RpcServices;
 };
type EthSepoliaService = 
 variant {
   Alchemy;
   Ankr;
   BlockPi;
   PublicNode;
   Sepolia;
 };
type EthMainnetService = 
 variant {
   Alchemy;
   Ankr;
   BlockPi;
   Cloudflare;
   Llama;
   PublicNode;
 };
type ChainType = 
 variant {
   Arbitrum;
   Base;
   Ethereum;
   ICP;
   Optimism;
   Polygon;
 };
service : {
  /// Claim HTLC on EVM chain
  claim_evm_htlc: (chain_id: nat, evm_htlc_address: text, secret: text) ->
   (Result_1);
  /// Claim an HTLC with the secret
  claim_htlc: (htlc_id: text, secret: text) -> (Result);
  /// Complete a partial fill
  complete_partial_fill: (fill_id: text, secret: text) -> (Result);
  /// Create HTLC on EVM chain
  create_evm_htlc: (chain_id: nat, evm_htlc_address: text, hashlock: 
   text, recipient: text, amount: nat, expiration: int) -> (Result_1);
  /// Create a new HTLC lock
  create_htlc: (recipient: principal, amount: nat, token_canister: principal,
   expiration_time: int, chain_type: ChainType, ethereum_address:
   opt text) -> (Result_1);
  /// Create a partial fill for an HTLC
  create_partial_fill: (htlc_id: text, amount: nat, secret_hash: text,
   resolver_address: text) -> (Result_1);
  /// Deposit cycles into the canister
  deposit_cycles: () -> ();
  /// Get linked 1inch order for an HTLC
  get_1inch_order: (htlc_id: text) -> (Result_10) query;
  /// Get active cross-chain swap orders
  get_active_orders: (page: opt nat, limit: opt nat, src_chain: opt nat,
   dst_chain: opt nat) -> (Result_1);
  /// Get all active resolvers
  get_active_resolvers: () -> (vec Resolver) query;
  /// Get chain configuration
  get_chain_config: (chain_id: nat) -> (Result_9) query;
  /// Get cycles balance
  get_cycles_balance: () -> (nat) query;
  /// Get escrow factory contract address
  get_escrow_factory_address: (chain_id: nat) -> (Result_1);
  /// Get balance of an address on EVM chain
  get_evm_balance: (chain_id: nat, address: text) -> (Result_1);
  /// Get latest block number from EVM chain
  get_evm_block_number: (chain_id: nat) -> (Result_8);
  /// Get EVM interaction details
  get_evm_interaction: (interaction_id: text) -> (Result_7) query;
  /// Get all EVM interactions for an HTLC
  get_evm_interactions_by_htlc: (htlc_id: text) ->
   (vec EvmHtlcInteraction) query;
  /// Get transaction receipt from EVM chain
  get_evm_transaction_receipt: (chain_id: nat, tx_hash: text) -> (Result_1);
  /// Get HTLC details
  get_htlc: (htlc_id: text) -> (Result_6) query;
  /// Get all partial fills for an HTLC
  get_htlc_partial_fills: (htlc_id: text) -> (Result_5) query;
  /// Get all HTLCs for a principal
  get_htlcs_by_principal: ("principal": principal) -> (vec HTLC) query;
  /// Get secrets and data for withdrawal and cancellation
  get_order_secrets: (order_hash: text) -> (Result_1);
  /// Get orders by maker address
  get_orders_by_maker: (maker_address: text, page: opt nat, limit: opt nat,
   src_chain_id: opt nat, dst_chain_id: opt nat) -> (Result_1);
  /// Get partial fill details
  get_partial_fill: (fill_id: text) -> (Result_4) query;
  /// Get resolver details
  get_resolver: (address: text) -> (Result_3) query;
  /// Get resolvers supporting a specific chain
  get_resolvers_for_chain: (chain_type: ChainType) -> (vec Resolver) query;
  /// Get available tokens for a specific chain
  get_tokens: (chain_id: nat) -> (Result_1);
  /// Simple greeting function for testing
  greet: (name: text) -> (text) query;
  /// Check if an order is active and can be filled
  is_order_active: (order_hash: text) -> (Result_2);
  /// Link a 1inch order to an HTLC
  link_1inch_order: (htlc_id: text, oneinch_order: OneInchOrder,
   is_source_chain: bool, partial_fill_index: opt nat) -> (Result);
  /// Parse order secrets response to extract secret for HTLC claim
  parse_order_secrets_for_htlc: (order_hash: text) -> (Result_1);
  /// Refund HTLC on EVM chain
  refund_evm_htlc: (chain_id: nat, evm_htlc_address: text) -> (Result_1);
  /// Refund an expired HTLC
  refund_htlc: (htlc_id: text) -> (Result);
  /// Register a new resolver
  register_resolver: (address: text, supported_chains: vec ChainType) ->
   (Result);
  /// Set the hashlock for an HTLC (called after secret is generated)
  set_htlc_hashlock: (htlc_id: text, hashlock: blob) -> (Result);
  /// Test 1inch API connectivity
  test_1inch_api: () -> (Result_1);
  /// Test EVM RPC connectivity
  test_evm_rpc: (chain_id: nat) -> (Result_1);
  /// Test getting active orders (limited to first page)
  test_get_active_orders: () -> (Result_1);
  /// Test method to check if we can make a basic HTTP request
  test_http_request: () -> (Result_1);
  transform: (record {
                context: blob;
                response: HttpResponseResult;
              }) -> (HttpResponseResult) query;
  /// Update chain configuration
  update_chain_config: (chain_id: nat, config: EvmChainConfig) -> (Result);
  /// Update resolver status
  update_resolver_status: (address: text, is_active: bool) -> (Result);
}
