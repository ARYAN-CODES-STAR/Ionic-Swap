type TokenAddress = text;
type Timestamp = int;
type SwapStatus = 
 variant {
   Completed;
   Expired;
   Locked;
   Pending;
   Refunded;
 };
type SwapId = text;
type Signature = blob;
type Secret = blob;
type Result_2 = 
 variant {
   err: OrderError;
   ok;
 };
type Result_1 = 
 variant {
   err: OrderError;
   ok: OrderId;
 };
type Result = 
 variant {
   err: OrderError;
   ok: SwapId;
 };
type OrderStatus = 
 variant {
   Cancelled;
   Expired;
   Matched;
   Open;
 };
type OrderId = text;
type OrderError = 
 variant {
   InsufficientFunds;
   InvalidAmount;
   InvalidSecret;
   InvalidSignature;
   OrderAlreadyMatched;
   OrderExpired;
   OrderNotFound;
   SwapNotFound;
   TimelockExpired;
   Unauthorized;
 };
type LimitOrder = 
 record {
   amountBuy: Amount;
   amountSell: Amount;
   hashedSecret: HashedSecret;
   isEvmUser: bool;
   orderId: OrderId;
   owner: principal;
   status: OrderStatus;
   timestamp: Timestamp;
   tokenBuy: TokenAddress;
   tokenSell: TokenAddress;
 };
type HtlcState = 
 record {
   counterparty: principal;
   createdAt: Timestamp;
   hashedSecret: HashedSecret;
   initiator: principal;
   status: SwapStatus;
   swapId: SwapId;
   timelock: Timestamp;
 };
type HashedSecret = text;
type CrossChainOrderbook = 
 service {
   cancelOrder: (orderId: OrderId) -> (Result_2);
   claimFunds: (swapId: SwapId, secret: Secret) -> (Result_2);
   getActiveSwaps: () -> (vec HtlcState) query;
   getOpenOrders: () -> (vec LimitOrder) query;
   getOrder: (orderId: OrderId) -> (opt LimitOrder) query;
   getSwap: (swapId: SwapId) -> (opt HtlcState) query;
   getTokenCanister: () -> (opt principal) query;
   getUserOrders: (user: principal) -> (vec LimitOrder) query;
   placeIcpOrder: (tokenSell: TokenAddress, amountSell: Amount, tokenBuy:
    TokenAddress, amountBuy: Amount, hashedSecret: HashedSecret) ->
    (Result_1);
   refundFunds: (swapId: SwapId) -> (Result_2);
   setTokenCanister: (canisterId: principal) -> (Result_2);
   submitEvmOrder: (tokenSell: TokenAddress, amountSell: Amount, tokenBuy:
    TokenAddress, amountBuy: Amount, hashedSecret: HashedSecret, signature:
    Signature) -> (Result_1);
   takeOrder: (orderId: OrderId) -> (Result);
 };
type Amount = nat;
service : () -> CrossChainOrderbook
